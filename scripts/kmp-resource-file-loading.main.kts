@file:Repository("https://repo1.maven.org/maven2/")
@file:DependsOn("org.json:json:20240303")

import org.json.JSONObject
import java.io.File

data class ResourceData<T>(
    val groups: List<String>,
    val groupFullName: String?,
    val name: String,
    val value: T,
)

fun defaultAutoGenerationMessage(scriptFilePath: String): String {
    return buildString {
        appendLine(" * Auto-generated content.")
        appendLine(" * ")
        appendLine(" * ⚠️ **DO NOT MODIFY THIS FILE MANUALLY** ⚠️")
        appendLine(" * ")
        appendLine(" * This file is automatically generated by the $scriptFilePath script.")
        appendLine(" * All changes will be overwritten when the script is run again.")
        appendLine(" * ")
        appendLine(" * To add updated content:")
        appendLine(" * 1. Add your file to the tokens/ directory")
        appendLine(" * 2. Run: kotlin $scriptFilePath")
        appendLine(" * ")
        appendLine(" * @generated by $scriptFilePath")
    }
}

fun <T> List<ResourceData<T?>>.filterNull(): List<ResourceData<T>> {
    val nonNullList = mutableListOf<ResourceData<T>>()
    forEach { resource ->
        if (resource.value != null) {
            nonNullList.add(
                ResourceData(
                    groups = resource.groups,
                    groupFullName = resource.groupFullName,
                    name = resource.name,
                    value = resource.value,
                )
            )
        }
    }
    return nonNullList
}

fun <T> readFileResourceFile(
    file: File,
    resourceMap: (JSONObject) -> T,
): List<ResourceData<T>> {
    val fileContent = file.readText()
    val json = JSONObject(fileContent)
    val variablesJsonArray = json.getJSONArray("variables")
    val resources = mutableListOf<ResourceData<T>>()
    println("Found ${variablesJsonArray.length()} variables")
    repeat(times = variablesJsonArray.length()) { index ->
        val variableJsonObject = variablesJsonArray.getJSONObject(index)
        if (!variableJsonObject.optBoolean("hiddenFromPublishing")) {
            val name = variableJsonObject.getString("name")
            val resolvedValues = variableJsonObject.getJSONObject("resolvedValuesByMode")
            resolvedValues.keys().asSequence().firstOrNull()?.let { resolvedValueKey ->
                val resolvedValueKeyObject = resolvedValues.getJSONObject(resolvedValueKey)
                resources.add(
                    ResourceData(
                        groups = name.sanitizedGroups(),
                        groupFullName = name.sanitizedClassName(),
                        name = name.sanitizedValueName(),
                        value = resourceMap(resolvedValueKeyObject),
                    )
                )
            }
        }
    }
    return resources
}

fun <T> readFileResourceFileByMode(
    file: File,
    modeKey: String,
    resourceMap: (JSONObject) -> T,
): List<ResourceData<T>> {
    val fileContent = file.readText()
    val json = JSONObject(fileContent)
    val variablesJsonArray = json.getJSONArray("variables")
    val resources = mutableListOf<ResourceData<T>>()
    println("Found ${variablesJsonArray.length()} variables")
    repeat(times = variablesJsonArray.length()) { index ->
        val variableJsonObject = variablesJsonArray.getJSONObject(index)
        if (!variableJsonObject.optBoolean("hiddenFromPublishing")) {
            val name = variableJsonObject.getString("name")
            val resolvedValues = variableJsonObject.getJSONObject("resolvedValuesByMode")
            if (resolvedValues.has(modeKey)) {
                val resolvedValueKeyObject = resolvedValues.getJSONObject(modeKey)
                resources.add(
                    ResourceData(
                        groups = name.sanitizedGroups(),
                        groupFullName = name.sanitizedClassName(),
                        name = name.sanitizedValueName(),
                        value = resourceMap(resolvedValueKeyObject),
                    )
                )
            }
        }
    }
    return resources
}

fun String.sanitizedGroups(): List<String> {
    val groups = split("/")
    val valueName = groups.subList(0, groups.lastIndex)
    return valueName.map { group ->
        group
            .split("-")
            .joinToString(separator = "") { word ->
                word.replaceFirstChar { char -> char.uppercase() }
            }
    }
}

fun String.sanitizedValueName(): String {
    val groups = split("/")
    var valueName = groups[groups.lastIndex]
    if (valueName.isValueNumberOnly()) {
        valueName = groups[groups.lastIndex - 1] + groups[groups.lastIndex]
    }
    return valueName
        .split("/")
        .joinToString("") { group ->
            group
                .split("-")
                .joinToString(separator = "") { word ->
                    word.replaceFirstChar { char -> char.uppercase() }
                }
        }
        .replaceFirstChar { char -> char.lowercase() }
}

fun String.sanitizedClassName(): String {
    val groups = split("/")
    val valueName = if(groups.size > 1){
        groups.subList(0, groups.lastIndex)
    } else {
        groups
    }
    return valueName.joinToString("") { group ->
        group
            .split("-")
            .joinToString(separator = "") { word ->
                word.replaceFirstChar { char -> char.uppercase() }
            }
    }
}

fun String.isValueNumberOnly(): Boolean {
    return all { it.isDigit() }
}